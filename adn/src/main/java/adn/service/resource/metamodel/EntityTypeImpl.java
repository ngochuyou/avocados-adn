/**
 * 
 */
package adn.service.resource.metamodel;

import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import org.hibernate.graph.spi.SubGraphImplementor;
import org.hibernate.id.IdentifierGenerator;
import org.hibernate.metamodel.model.domain.internal.AbstractIdentifiableType;
import org.hibernate.metamodel.model.domain.spi.EntityTypeDescriptor;
import org.hibernate.metamodel.model.domain.spi.IdentifiableTypeDescriptor;
import org.hibernate.property.access.spi.Getter;
import org.hibernate.property.access.spi.Setter;
import org.hibernate.tuple.ValueGeneration;

import adn.service.resource.local.ResourceManagerFactoryBuilder;

/**
 * @author Ngoc Huy
 *
 */
@SuppressWarnings("serial")
public class EntityTypeImpl<D> extends AbstractIdentifiableType<D> implements EntityTypeDescriptor<D> {

	private int propertySpan;
	private final Map<String, Integer> indexMap = new HashMap<>();
	private ValueGeneration[] valueGenerations;
	private Class<?>[] propertyTypes;
	private Getter[] getters;
	private Setter[] setters;
	private boolean[] autoGeneratedMarkers;

	private Getter idGetter;
	private Setter idSetter;
	private IdentifierGenerator identifierGenerator;

	private InFlightAccess access = new InFlightAccessImpl();

	// @formatter:off
	public EntityTypeImpl(
		Class<D> entityType,
		String entityName,
		boolean hasIdentifier,
		boolean isVersioned,
		IdentifiableTypeDescriptor<? super D> superType) {
		super(
				entityType,
				entityName,
				superType,
				false,
				hasIdentifier,
				isVersioned,
				null
		);
	}
	// @formatter:on

	public InFlightAccess getInflightAccess() throws IllegalAccessException {
		if (access == null) {
			throw new IllegalAccessException("Access to " + this.getClass().getName() + " was closed");
		}

		return access;
	}

	public void closeAccess() {
		access = null;
	}

	@Override
	public PersistenceType getPersistenceType() {
		// TODO Auto-generated method stub
		return PersistenceType.ENTITY;
	}

	@Override
	public BindableType getBindableType() {
		// TODO Auto-generated method stub
		return BindableType.ENTITY_TYPE;
	}

	@Override
	public Class<D> getBindableJavaType() {
		// TODO Auto-generated method stub
		return getJavaType();
	}

	private EntityTypeImpl<? super D> locateSuperType() {
		return (EntityTypeImpl<? super D>) getSupertype();
	}

	public int getPropertyIndex(String propertyName) {
		if (indexMap.keySet().contains(propertyName)) {
			return indexMap.get(propertyName);
		}

		if (getSupertype() != null) {
			return locateSuperType().getPropertyIndex(propertyName);
		}

		throw new IllegalArgumentException("Unable to locate property " + propertyName);
	}

	public Class<?> getPropertyType(String propertyName) {
		if (indexMap.keySet().contains(propertyName)) {
			return propertyTypes[indexMap.get(propertyName)];
		}

		if (getSupertype() != null) {
			return locateSuperType().getPropertyType(propertyName);
		}

		throw new IllegalArgumentException("Unable to locate type of property " + propertyName);
	}

	public Getter[] getGetters() {
		return getters;
	}

	public Setter[] getSetters() {
		return setters;
	}

	public Getter getGetter(String propertyName) {
		if (indexMap.keySet().contains(propertyName)) {
			return getters[indexMap.get(propertyName)];
		}

		if (getSupertype() != null) {
			return locateSuperType().getGetter(propertyName);
		}

		throw new IllegalArgumentException("Unable to locate getter of property " + propertyName);
	}

	public Setter getSetter(String propertyName) {
		if (indexMap.keySet().contains(propertyName)) {
			return setters[indexMap.get(propertyName)];
		}

		if (getSupertype() != null) {
			return locateSuperType().getSetter(propertyName);
		}

		throw new IllegalArgumentException("Unable to locate setter of property " + propertyName);
	}

	public Getter getIdGetter() {
		return idGetter;
	}

	public Setter getIdSetter() {
		return idSetter;
	}

	public int getPropertySpan() {
		return propertySpan;
	}

	public boolean[] getAutoGeneratedMarkers() {
		return autoGeneratedMarkers;
	}

	public boolean isPropertyAutoGenerated(String propertyName) {
		if (indexMap.keySet().contains(propertyName)) {
			return autoGeneratedMarkers[indexMap.get(propertyName)];
		}

		if (getSupertype() != null) {
			return locateSuperType().isPropertyAutoGenerated(propertyName);
		}

		throw new IllegalArgumentException("Unable to locate valuegeneration of property " + propertyName);
	}

	public ValueGeneration getPropertyValueGeneration(String propertyName) {
		if (indexMap.keySet().contains(propertyName)) {
			return valueGenerations[indexMap.get(propertyName)];
		}

		if (getSupertype() != null) {
			return locateSuperType().getPropertyValueGeneration(propertyName);
		}

		throw new IllegalArgumentException("Unable to locate valuegeneration of property " + propertyName);
	}

	@Override
	public <S extends D> SubGraphImplementor<S> makeSubGraph(Class<S> subType) {
		// TODO Auto-generated method stub
		ResourceManagerFactoryBuilder.unsupport();
		return null;
	}

	@Override
	public SubGraphImplementor<D> makeSubGraph() {
		// TODO Auto-generated method stub
		ResourceManagerFactoryBuilder.unsupport();
		return null;
	}

	public IdentifierGenerator getIdentifierGenerator() {
		return identifierGenerator;
	}

	interface InFlightAccess {

		void setIdGetter(Getter getter);

		void setIdSetter(Setter setter);

		void setIdentifierGenerator(IdentifierGenerator generator);

		void setGetters(Getter[] getters);

		void setSetters(Setter[] setters);

		void setValueGenerations(ValueGeneration[] valueGenerations);

		void setPropertyTypes(Class<?>[] types);

		void putIndex(int index, String propertyName);

		void increasePropertySpan();

		void setAutoGeneratedMarkers(boolean[] markers);

	}

	private class InFlightAccessImpl implements InFlightAccess {

		@Override
		public void setIdGetter(Getter getter) {
			// TODO Auto-generated method stub
			idGetter = getter;
		}

		@Override
		public void setIdSetter(Setter setter) {
			// TODO Auto-generated method stub
			idSetter = setter;
		}

		@Override
		public void setIdentifierGenerator(IdentifierGenerator generator) {
			// TODO Auto-generated method stub
			identifierGenerator = generator;
		}

		@Override
		public void setGetters(Getter[] gettersArg) {
			// TODO Auto-generated method stub
			getters = gettersArg;
		}

		@Override
		public void setSetters(Setter[] settersArg) {
			// TODO Auto-generated method stub
			setters = settersArg;
		}

		@Override
		public void putIndex(int index, String propertyName) {
			// TODO Auto-generated method stub
			indexMap.put(propertyName, index);
		}

		@Override
		public void increasePropertySpan() {
			propertySpan++;
		}

		@Override
		public void setValueGenerations(ValueGeneration[] valueGenerationsArg) {
			// TODO Auto-generated method stub
			valueGenerations = valueGenerationsArg;
		}

		@Override
		public void setPropertyTypes(Class<?>[] types) {
			// TODO Auto-generated method stub
			propertyTypes = types;
		}

		@Override
		public void setAutoGeneratedMarkers(boolean[] markers) {
			// TODO Auto-generated method stub
			autoGeneratedMarkers = markers;
		}

	}

	public String log() {
		// @formatter:off
		return String.format("Metamodel: %s\n"
				+ "\t-propertySpan: %d\n"
				+ "\t-indexMap: [%s]\n"
				+ "\t-valueGenerations: [%s]\n"
				+ "\t-propertyTypes: [%s]\n"
				+ "\t-getters: [%s]\n"
				+ "\t-setters: [%s]\n"
				+ "\t-autoGeneratedMarkers: [%s]\n"
				+ "\t-identifierGenerator: %s\n"
				+ "\t-superType: %s\n"
				+ "\t-declaredAttributes: \n%s\n"
				+ "\t-declaredSingularAttributes: \n%s\n"
				+ "\t-declaredPluralAttributes: \n%s\n"
				+ "\t-hasIdentifierProperty: %b\n"
				+ "\t-hasIdClass: %b\n"
				+ "\t-id: %s\n"
				+ "\t-idClassAttributes(in size): %d\n"
				+ "\t-isVersioned: %b\n"
				+ "\t-versionAttribute: %s",
				getName(),
				propertySpan,
				indexMap.entrySet().stream().sorted((l, r) -> Integer.compare(l.getValue(), r.getValue())).map(ele -> ele.getValue() + "|" + ele.getKey()).collect(Collectors.joining(", ")),
				Stream.of(valueGenerations)
					.map(ele -> {
						if (ele instanceof IdentifierGenerationHolder) {
							return "Determined by IdentifierGenerator|Generated by IdentifierGenerator";
						}
						
						return ele.getGenerationTiming() + "|" + (ele.getValueGenerator() != null ? ele.getValueGenerator().getClass().getName() : "NULL");
					})
					.collect(Collectors.joining(", ")),
				Stream.of(propertyTypes)
					.map(ele -> ele.getName())
					.collect(Collectors.joining(", ")),
				Stream.of(getters)
					.map(ele -> ele.getMember().getName())
					.collect(Collectors.joining(", ")),
				Stream.of(setters)
					.map(ele -> ele.getMethod().getName())
					.collect(Collectors.joining(", ")),	
				IntStream.range(0, propertySpan)
					.mapToObj(index -> String.valueOf(autoGeneratedMarkers[index]))
					.collect(Collectors.joining(", ")),
				identifierGenerator != null ? identifierGenerator.getClass().getName() : "NULL",
				getSupertype() != null ? getSupertype().getName() : "NULL",
				getDeclaredAttributes().stream().map(ele -> String.format("\t\t-name: %s\n"
						+ "\t\t-persistentAttributeType: %s\n"
						+ "\t\t-declaringType: %s\n"
						+ "\t\t-javaMember: %s\n"
						+ "\t\t-isAssociation: %b\n"
						+ "\t\t-isCollection: %b",
						ele.getName(),
						ele.getPersistentAttributeType(),
						ele.getDeclaringType().getJavaType(),
						ele.getJavaMember().getName(),
						ele.isAssociation(),
						ele.isCollection())).collect(Collectors.joining("\n\t\t--------------------\n")),
				getDeclaredSingularAttributes().stream().map(ele -> String.format("\t\t-name: %s\n"
						+ "\t\t-isId: %b\n"
						+ "\t\t-isVersion: %b\n"
						+ "\t\t-isOptional: %b", 
						ele.getName(),
						ele.isId(),
						ele.isVersion(),
						ele.isOptional())).collect(Collectors.joining("\n\t\t--------------------\n")),
				getDeclaredPluralAttributes().stream().map(ele -> String.format("\t\t-name: %s\n"
						+ "\t\t-collectionType: %s\n"
						+ "\t\t-elementType: %s\n",
						ele.getName(),
						ele.getCollectionType(),
						ele.getElementType().getJavaType().getName())).collect(Collectors.joining("\n\t\t--------------------\n")),
				hasSingleIdAttribute(),
				hasIdClass(),
				hasSingleIdAttribute() ? getId(getIdType().getJavaType()).getName() + ": " + getId(getIdType().getJavaType()).getJavaType().getName() : "NULL",
				hasIdClass() ? getIdClassAttributes().size() : 0,
				hasVersionAttribute(),
				hasVersionAttribute() ? getDeclaredVersion().getName() + ": " + getDeclaredVersion().getJavaType().getName() : "NULL");
		// @formatter:on
	}

}
