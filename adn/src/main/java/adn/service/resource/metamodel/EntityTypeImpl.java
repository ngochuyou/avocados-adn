/**
 * 
 */
package adn.service.resource.metamodel;

import java.util.HashMap;
import java.util.Map;

import org.hibernate.graph.spi.SubGraphImplementor;
import org.hibernate.metamodel.model.domain.internal.AbstractIdentifiableType;
import org.hibernate.metamodel.model.domain.spi.EntityTypeDescriptor;
import org.hibernate.metamodel.model.domain.spi.IdentifiableTypeDescriptor;
import org.hibernate.property.access.spi.Getter;
import org.hibernate.property.access.spi.Setter;
import org.hibernate.tuple.ValueGeneration;

import adn.service.resource.local.ResourceManagerFactoryBuilder;

/**
 * @author Ngoc Huy
 *
 */
@SuppressWarnings("serial")
public class EntityTypeImpl<D> extends AbstractIdentifiableType<D> implements EntityTypeDescriptor<D> {

//	private final Map<String, PersistentAttribute<D, ?>> attributeMap = new HashMap<>();
//	private final Map<String, SingularPersistentAttribute<D, ?>> singularAttributeMap = new HashMap<>();
//	private final Map<String, PluralPersistentAttribute<D, ? extends Collection<?>, ?>> pluralAttributeMap = new HashMap<>();

	private int propertySpan;
	private final Map<String, Integer> indexMap = new HashMap<>();
	private ValueGeneration[] valueGenerations;
	private Class<?>[] propertyTypes;
	private Getter[] getters;
	private Setter[] setters;
	private boolean[] autoGeneratedMarkers;

	private Getter idGetter;
	private Setter idSetter;
	private ValueGeneration identifierValueGeneration;

	private InFlightAccess access = new InFlightAccessImpl();

	// @formatter:off
	public EntityTypeImpl(
		Class<D> entityType,
		String entityName,
		boolean hasIdentifier,
		boolean isVersioned,
		IdentifiableTypeDescriptor<? super D> superType) {
		super(
				entityType,
				entityName,
				superType,
				false,
				hasIdentifier,
				isVersioned,
				null
		);
	}
	// @formatter:on

	public InFlightAccess getInflightAccess() throws IllegalAccessException {
		if (access == null) {
			throw new IllegalAccessException("Access to " + this.getClass().getName() + " was closed");
		}

		return access;
	}

	public void closeAccess() {
		access = null;
	}

	@Override
	public PersistenceType getPersistenceType() {
		// TODO Auto-generated method stub
		return PersistenceType.ENTITY;
	}

	@Override
	public BindableType getBindableType() {
		// TODO Auto-generated method stub
		return BindableType.ENTITY_TYPE;
	}

	@Override
	public Class<D> getBindableJavaType() {
		// TODO Auto-generated method stub
		return getJavaType();
	}

	private EntityTypeImpl<? super D> locateSuperType() {
		return (EntityTypeImpl<? super D>) getSupertype();
	}

	public int getPropertyIndex(String propertyName) {
		if (indexMap.keySet().contains(propertyName)) {
			return indexMap.get(propertyName);
		}

		if (getSupertype() != null) {
			return locateSuperType().getPropertyIndex(propertyName);
		}

		throw new IllegalArgumentException("Unable to locate property " + propertyName);
	}

	public Class<?> getPropertyType(String propertyName) {
		if (indexMap.keySet().contains(propertyName)) {
			return propertyTypes[indexMap.get(propertyName)];
		}

		if (getSupertype() != null) {
			return locateSuperType().getPropertyType(propertyName);
		}

		throw new IllegalArgumentException("Unable to locate type of property " + propertyName);
	}

	public Getter[] getGetters() {
		return getters;
	}

	public Setter[] getSetters() {
		return setters;
	}

	public Getter getGetter(String propertyName) {
		if (indexMap.keySet().contains(propertyName)) {
			return getters[indexMap.get(propertyName)];
		}

		if (getSupertype() != null) {
			return locateSuperType().getGetter(propertyName);
		}

		throw new IllegalArgumentException("Unable to locate getter of property " + propertyName);
	}

	public Setter getSetter(String propertyName) {
		if (indexMap.keySet().contains(propertyName)) {
			return setters[indexMap.get(propertyName)];
		}

		if (getSupertype() != null) {
			return locateSuperType().getSetter(propertyName);
		}

		throw new IllegalArgumentException("Unable to locate setter of property " + propertyName);
	}

	public Getter getIdGetter() {
		return idGetter;
	}

	public Setter getIdSetter() {
		return idSetter;
	}

	public ValueGeneration getIdValueGeneration() {
		return identifierValueGeneration;
	}

	public int getPropertySpan() {
		return propertySpan;
	}

	public boolean[] getAutoGeneratedMarkers() {
		return autoGeneratedMarkers;
	}

	public ValueGeneration getPropertyValueGeneration(String propertyName) {
		if (indexMap.keySet().contains(propertyName)) {
			return valueGenerations[indexMap.get(propertyName)];
		}

		if (getSupertype() != null) {
			return locateSuperType().getPropertyValueGeneration(propertyName);
		}

		throw new IllegalArgumentException("Unable to locate valuegeneration of property " + propertyName);
	}

	@Override
	public <S extends D> SubGraphImplementor<S> makeSubGraph(Class<S> subType) {
		// TODO Auto-generated method stub
		ResourceManagerFactoryBuilder.unsupport();
		return null;
	}

	@Override
	public SubGraphImplementor<D> makeSubGraph() {
		// TODO Auto-generated method stub
		ResourceManagerFactoryBuilder.unsupport();
		return null;
	}

	public ValueGeneration getIdentifierValueGeneration() {
		return identifierValueGeneration;
	}

	interface InFlightAccess {

		void setIdGetter(Getter getter);

		void setIdSetter(Setter setter);

		void setIdentifierValueGeneration(ValueGeneration valueGeneration);

		void setGetters(Getter[] getters);

		void setSetters(Setter[] setters);

		void setValueGenerations(ValueGeneration[] valueGenerations);

		void setPropertyTypes(Class<?>[] types);

		void putIndex(int index, String propertyName);

		void increasePropertySpan();

	}

	private class InFlightAccessImpl implements InFlightAccess {

		@Override
		public void setIdGetter(Getter getter) {
			// TODO Auto-generated method stub
			idGetter = getter;
		}

		@Override
		public void setIdSetter(Setter setter) {
			// TODO Auto-generated method stub
			idSetter = setter;
		}

		@Override
		public void setIdentifierValueGeneration(ValueGeneration valueGeneration) {
			// TODO Auto-generated method stub
			identifierValueGeneration = valueGeneration;
		}

		@Override
		public void setGetters(Getter[] gettersArg) {
			// TODO Auto-generated method stub
			getters = gettersArg;
		}

		@Override
		public void setSetters(Setter[] settersArg) {
			// TODO Auto-generated method stub
			setters = settersArg;
		}

		@Override
		public void putIndex(int index, String propertyName) {
			// TODO Auto-generated method stub
			indexMap.put(propertyName, index);
		}

		@Override
		public void increasePropertySpan() {
			propertySpan++;
		}

		@Override
		public void setValueGenerations(ValueGeneration[] valueGenerationsArg) {
			// TODO Auto-generated method stub
			valueGenerations = valueGenerationsArg;
		}

		@Override
		public void setPropertyTypes(Class<?>[] types) {
			// TODO Auto-generated method stub
			propertyTypes = types;
		}

	}

}
