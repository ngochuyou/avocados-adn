/**
 * 
 */
package adn.service.resource.metamodel;

import static adn.service.resource.local.ResourceManagerFactory.unsupport;

import java.io.Serializable;
import java.lang.reflect.Field;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.Version;
import javax.persistence.metamodel.EmbeddableType;
import javax.persistence.metamodel.EntityType;
import javax.persistence.metamodel.ManagedType;
import javax.persistence.metamodel.Metamodel;

import org.hibernate.FetchMode;
import org.hibernate.MappingException;
import org.hibernate.Session;
import org.hibernate.dialect.Dialect;
import org.hibernate.engine.spi.Mapping;
import org.hibernate.id.IdentifierGenerator;
import org.hibernate.id.factory.IdentifierGeneratorFactory;
import org.hibernate.mapping.KeyValue;
import org.hibernate.mapping.Property;
import org.hibernate.mapping.RootClass;
import org.hibernate.mapping.Selectable;
import org.hibernate.mapping.Table;
import org.hibernate.mapping.Value;
import org.hibernate.mapping.ValueVisitor;
import org.hibernate.service.ServiceRegistry;
import org.hibernate.tuple.GenerationTiming;
import org.hibernate.type.Type;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

import adn.service.resource.local.AnnotationBasedResourceValueGeneration;
import adn.service.resource.local.ContextBuildingService;
import adn.service.resource.local.Metadata;
import adn.service.resource.local.NamingStrategy;
import adn.service.resource.local.ResourceDescriptor;
import adn.service.resource.local.ResourceDescriptorImpl;
import adn.service.resource.local.ResourceIdentifier;
import adn.service.resource.local.ResourceManagerFactory;
import adn.service.resource.local.ResourcePropertyValueGenerator;
import adn.service.resource.models.NamedResource;
import adn.utilities.StringHelper;
import javassist.Modifier;

/**
 * @author Ngoc Huy
 *
 */
public class MetamodelImpl implements Metamodel {

	private final Logger logger = LoggerFactory.getLogger(this.getClass());

	private final ResourceManagerFactory managerFactory;

	private final Map<String, ResourceDescriptor<?>> descriptorsByName = new HashMap<>();

	private final Set<String> managedModels;

	private static final Map<GenerationTiming, ResourceIdentifierValueGeneration> valueGenerationMap = new HashMap<>();

	private final Map<String, EntityType<?>> entitiesByName;

	/**
	 * @throws SecurityException
	 * @throws NoSuchMethodException
	 * @throws NoSuchFieldException
	 * 
	 */
	public MetamodelImpl(ContextBuildingService serviceRegistry, ResourceManagerFactory resourceManagerFactory)
			throws NoSuchMethodException, SecurityException, NoSuchFieldException {
		// TODO Auto-generated constructor stub
		Assert.notNull(resourceManagerFactory, "ResourceManagerFactory must not be null");
		this.managerFactory = resourceManagerFactory;

		Metadata metadata = serviceRegistry.getService(Metadata.class);
		NamingStrategy resourceNamingStrategy = serviceRegistry.getService(NamingStrategy.class);

		Assert.notNull(metadata, "Metadata must not be null");

		Set<Class<?>> modelClassSet = metadata.getModelClassSet();

		managedModels = modelClassSet.stream().map(clazz -> resourceNamingStrategy.getName(clazz))
				.collect(Collectors.toSet());
		entitiesByName = new HashMap<>(managedModels.size());

		ModelBinder binder = new ModelBinder();

		for (Class<?> modelClass : modelClassSet) {
			String resourceName = resourceNamingStrategy.getName(modelClass);
			ResourceClass resourceClass = new ResourceClass(resourceName, modelClass);

			binder.bindType(resourceClass);

			EntityTypeImpl<?> metamodel;

			entitiesByName.put(resourceName, metamodel = new EntityTypeImpl<>(modelClass, resourceName, resourceClass));

			ResourceDescriptor<?> descriptor = createDescriptor(metamodel);

			descriptorsByName.put(resourceName, descriptor);
			// @formatter:off
			logger.debug(String.format("\nCreated descriptor for type: %s with name: %s\n"
					+ "\t-idGetter: %s returns %s\n"
					+ "\t-idSetter: %s returns void\n"
					+ "\t-isIdentifierAutoGenerated: %s\n"
					+ "\t-identifierValueGenerator: %s\n"
					+ "\t-generationTiming: %s",
					modelClass.getName(), resourceNamingStrategy.getName(modelClass),
					descriptor.getIdentifierGetter().getMethodName(), descriptor.getIdentifierGetter().getReturnType(),
					descriptor.getIdentifierSetter().getMethodName(),
					Boolean.valueOf(descriptor.isIdentifierAutoGenerated()),
					(descriptor.isIdentifierAutoGenerated() ? 
							descriptor.getIdentifierValueGeneration().getValueGenerator().getClass().getName() :
								"NONE"),
					(descriptor.isIdentifierAutoGenerated() ? 
							descriptor.getIdentifierValueGeneration().getGenerationTiming() :
								"NEVER")));
			logger.trace(descriptor.toString());
			descriptor.cleanUp();
			// @formatter:on
		}
	}

	private ResourceDescriptor<?> createDescriptor(EntityTypeImpl<?> metamodel)
			throws NoSuchMethodException, SecurityException {
		return new ResourceDescriptorImpl<>(metamodel, managerFactory);
	}

	@Override
	public <X> EntityTypeImpl<X> entity(Class<X> cls) {
		// TODO Auto-generated method stub
		return entity(managerFactory.getContextBuildingService().getService(NamingStrategy.class).getName(cls));
	}

	@SuppressWarnings("unchecked")
	public <X> EntityTypeImpl<X> entity(String name) {
		// TODO Auto-generated method stub
		return (EntityTypeImpl<X>) entitiesByName.get(name);
	}

	@Override
	public <X> ManagedType<X> managedType(Class<X> cls) {
		// TODO Auto-generated method stub
		return entity(cls);
	}

	@Override
	public <X> EmbeddableType<X> embeddable(Class<X> cls) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Set<ManagedType<?>> getManagedTypes() {
		// TODO Auto-generated method stub
		return Collections.unmodifiableSet(new HashSet<>(entitiesByName.values()));
	}

	@Override
	public Set<EntityType<?>> getEntities() {
		// TODO Auto-generated method stub
		return Collections.unmodifiableSet(new HashSet<>(entitiesByName.values()));
	}

	@Override
	public Set<EmbeddableType<?>> getEmbeddables() {
		// TODO Auto-generated method stub
		return Collections.emptySet();
	}

	@SuppressWarnings("unchecked")
	public <T> ResourceDescriptor<T> getResourceDescriptor(String resourceName) {
		// TODO Auto-generated method stub
		if (!managedModels.contains(resourceName)) {
			return null;
		}

		return (ResourceDescriptor<T>) descriptorsByName.get(resourceName);
	}

	public Set<ResourceDescriptor<?>> getResourceDescriptors() {
		// TODO Auto-generated method stub
		return Collections.unmodifiableSet(new HashSet<>(descriptorsByName.values()));
	}

	public ResourceManagerFactory getManagerFactory() {
		return managerFactory;
	}

	private class ModelBinder {

		void bindType(ResourceClass type) {
			for (Field f : type.getType().getDeclaredFields()) {
				type.addProperty(bindProperty(new Property(), f));
				type.addPropertyType(f.getClass());
			}
		}

		Property bindProperty(Property prop, Field f) {
			prop = prop == null ? new Property() : prop;

			prop.setName(f.getName());
			bindValue(prop, f);
			prop.setCascade(null);
			prop.setUpdateable(Modifier.isFinal(f.getModifiers()));
			prop.setSelectable(false);
			bindValueGeneration(prop, f);
			prop.setLazy(false);
			prop.setOptional(f.getDeclaredAnnotation(Nullable.class) != null);

			return prop;
		}

		void bindValueGeneration(Property prop, Field f) {
			if (f.getDeclaredAnnotation(GeneratedValue.class) == null) {
				return;
			}

			ResourceIdentifier anno;

			if ((anno = f.getDeclaredAnnotation(ResourceIdentifier.class)) == null) {
				throw new IllegalArgumentException(
						"Unable to locate " + ResourceIdentifier.class + " on identifier: " + f.getName());
			}

			AnnotationBasedResourceValueGeneration generation = locateGeneration(anno.timing());

			prop.setValueGenerationStrategy(generation);
		}

		void bindValue(Property prop, Field f) {
			if (f.getDeclaredAnnotation(Id.class) != null) {
				prop.setValue(new IdentifierValue());
				return;
			}

			prop.setValue(f.getDeclaredAnnotation(Version.class) != null ? new VersionValue() : new SimpleValue());
		}

		private ResourceIdentifierValueGeneration locateGeneration(GenerationTiming timing) {
			if (valueGenerationMap.containsKey(timing)) {
				return valueGenerationMap.get(timing);
			}

			ResourceIdentifierValueGeneration generation;

			valueGenerationMap.put(timing, generation = new ResourceIdentifierValueGeneration(timing));

			return generation;
		}

	}

	public static class ResourceIdentifierValueGenerator implements ResourcePropertyValueGenerator<Serializable> {

		public static final ResourceIdentifierValueGenerator INSTANCE = new ResourceIdentifierValueGenerator();

		public static final String IDENTIFIER_PARTS_SEPERATOR = "_";

		@Override
		@Deprecated
		public Serializable generateValue(Session session, Object owner) {
			// TODO Auto-generated method stub
			unsupport();
			return null;
		}

		@Override
		public Serializable generateValue(ResourceManagerFactory factory, Object object) {
			// TODO Auto-generated method stub
			if (object instanceof NamedResource) {
				// @formatter:off
				NamedResource instance = (NamedResource) object;

				return new StringBuilder(instance.getDirectoryPath())
						.append(new Date().getTime())
						.append(IDENTIFIER_PARTS_SEPERATOR)
						.append(StringHelper.hash(instance.getName()))
						.append(instance.getExtension())
						.toString();
				// @formatter:on
			}

			return String.valueOf(new Date().getTime());
		}

	}

	public static class ResourceIdentifierValueGeneration extends AnnotationBasedResourceValueGeneration {

		private static final long serialVersionUID = 1L;

		private final ResourcePropertyValueGenerator<Serializable> generator = ResourceIdentifierValueGenerator.INSTANCE;

		/**
		 * @param timing
		 */
		public ResourceIdentifierValueGeneration(GenerationTiming timing) {
			super(timing);
			// TODO Auto-generated constructor stub
		}

		public ResourceIdentifierValueGeneration(ResourceIdentifierValueGeneration other) {
			super(GenerationTiming.valueOf(other.timing.toString()));
		}

		@Override
		public GenerationTiming getGenerationTiming() {
			// TODO Auto-generated method stub
			return timing;
		}

		@Override
		public ResourcePropertyValueGenerator<Serializable> getValueGenerator() {
			// TODO Auto-generated method stub
			return generator;
		}

		@Override
		public boolean referenceColumnInSql() {
			// TODO Auto-generated method stub
			unsupport();
			return false;
		}

		@Override
		public String getDatabaseGeneratedReferencedColumnValue() {
			// TODO Auto-generated method stub
			unsupport();
			return null;
		}

		@Override
		public void initialize(ResourceIdentifier annotation, Class<?> propertyType) {
			// TODO Auto-generated method stub
		}

	}

	public class SimpleValue implements Value {

		private static final long serialVersionUID = 1L;

		@Override
		public int getColumnSpan() {
			// TODO Auto-generated method stub
			return 0;
		}

		@Override
		public Iterator<Selectable> getColumnIterator() {
			// TODO Auto-generated method stub
			return null;
		}

		@Override
		public Type getType() throws MappingException {
			// TODO Auto-generated method stub
			return null;
		}

		@Override
		public FetchMode getFetchMode() {
			// TODO Auto-generated method stub
			return FetchMode.SELECT;
		}

		@Override
		public Table getTable() {
			// TODO Auto-generated method stub
			return null;
		}

		@Override
		public boolean hasFormula() {
			// TODO Auto-generated method stub
			return false;
		}

		@Override
		public boolean isAlternateUniqueKey() {
			// TODO Auto-generated method stub
			return false;
		}

		@Override
		public boolean isNullable() {
			// TODO Auto-generated method stub
			return false;
		}

		@Override
		public boolean[] getColumnUpdateability() {
			// TODO Auto-generated method stub
			return null;
		}

		@Override
		public boolean[] getColumnInsertability() {
			// TODO Auto-generated method stub
			return null;
		}

		@Override
		public void createForeignKey() throws MappingException {
			// TODO Auto-generated method stub
		}

		@Override
		public boolean isSimpleValue() {
			// TODO Auto-generated method stub
			return true;
		}

		@Override
		public boolean isValid(Mapping mapping) throws MappingException {
			// TODO Auto-generated method stub
			return true;
		}

		@Override
		public void setTypeUsingReflection(String className, String propertyName) throws MappingException {
			// TODO Auto-generated method stub
		}

		@Override
		public Object accept(ValueVisitor visitor) {
			// TODO Auto-generated method stub
			return null;
		}

		@Override
		public boolean isSame(Value other) {
			// TODO Auto-generated method stub
			return other instanceof SimpleValue;
		}

		@Override
		public ServiceRegistry getServiceRegistry() {
			// TODO Auto-generated method stub
			return null;
		}

	}

	public class IdentifierValue extends SimpleValue implements KeyValue {

		private static final long serialVersionUID = 1L;

		@Override
		public IdentifierGenerator createIdentifierGenerator(IdentifierGeneratorFactory identifierGeneratorFactory,
				Dialect dialect, String defaultCatalog, String defaultSchema, RootClass rootClass)
				throws MappingException {
			// TODO Auto-generated method stub
			return null;
		}

		@Override
		public boolean isIdentityColumn(IdentifierGeneratorFactory identifierGeneratorFactory, Dialect dialect) {
			// TODO Auto-generated method stub
			return true;
		}

		@Override
		public void createForeignKeyOfEntity(String entityName) {
			// TODO Auto-generated method stub
		}

		@Override
		public boolean isCascadeDeleteEnabled() {
			// TODO Auto-generated method stub
			return false;
		}

		@Override
		public String getNullValue() {
			// TODO Auto-generated method stub
			return null;
		}

		@Override
		public boolean isUpdateable() {
			// TODO Auto-generated method stub
			return false;
		}

	}

	public class VersionValue extends SimpleValue {

		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;

	}

}
